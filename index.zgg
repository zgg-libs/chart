
_colors := [
	[86, 166, 75],
	[224, 180, 0],
	[87, 148, 242],
	[250, 100, 0],
	[224, 47, 68],
	[242, 204, 12],
].map(v => '%02x%02x%02x' % v)

export func yAxisFromZero(step, fmt) {
	fmt = fmt ?? v => str(v)
	return (minVal, maxVal) => {
		begin := 0
		end   := int(maxVal / step)
		if end * step < maxVal {
			end++
		}
		return [
			[{value: v*step, label: fmt(v*step)} for v in begin..end],
			0,
		]
	}
}

export func yAxisFromMin(step, fmt) {
	fmt = fmt ?? v => str(v)
	return (minVal, maxVal) => {
		begin := int(minVal / step)
		end   := int(maxVal / step)
		if end * step < maxVal {
			end++
		}
		return [
			[{value: v*step, label: fmt(v*step)} for v in begin..end],
			minVal,
		]
	}
}

export func makeLineDrawer() {
	return func (canvas, n, datas, dataIndex, data, color, left, bottom, width, height, getY) {
		for i, value in data {
			x := left + (i + 0.5) * width / n
			y := getY(value)
			if i == 0 {
				canvas.moveTo(x, y)
			} else {
				canvas.lineTo(x, y)
			}
			canvas.circle(x, y, 2)
		}
		canvas.stroke(color)
	}
}

export func makeBarDrawer(barWidth, barMargin) {
	barWidth  = barWidth ?? 3
	barMargin = barMargin ?? 1.5
	distance := barWidth + barMargin
	return func(canvas, n, datas, dataIndex, data, color, left, bottom, width, height, getY) {
		ol := 0.5 * distance * (1 - len(datas))
		for i, value in data {
			x := left + (i + 0.5) * width / n
				+ ol + dataIndex * distance
			y := getY(value)
			canvas.rect(x - barWidth / 2.0, y, barWidth, bottom - y, ';$color')
		}
	}
}

DEFAULT_OPTIONS := {
	padding: 10,
	legend: {
		blockWidth  : 40,
		blockHeight : 8,
		itemMargin  : 10,
		textMargin  : 5,
		rowMargin   : 18,
	},
}

export func drawChart(canvas, rect, options) {
	[left, top, width, height] := rect
	title   := options.title
	names   := options.names
	datas   := options.datas
	yaxis   := options.yaxis
	legends := options.legends
	colors  := options.colors ?? _colors
	drawer  := options.drawer ?? makeLineDrawer()

	if canvas == nil {
		canvas = @drawing.Canvas(width, height, 'fff')
		left = 0
		top  = 0
	} else {
		left = left ?? 0
		top  = top  ?? 0
	}
    [tw, th] := title ? canvas.measureText(title): [0, 0]
	nh := when th {
		0 -> canvas.measureText('A')[1]
		else -> th
	}
	padding2 := DEFAULT_OPTIONS.padding * 2
	gTop     := top + th + DEFAULT_OPTIONS.padding
	gBottom  := top + height - nh - DEFAULT_OPTIONS.padding
	gLeft    := left + DEFAULT_OPTIONS.padding
	gRight   := left + width - padding2
	gWidth   := gRight - gLeft
	gHeight  := gBottom - gTop
	minValue := float(min(...datas.map(d => min(...d))))
	maxValue := float(max(...datas.map(d => max(...d))))

	// Process legends
	legendRows   := []
	legendHeight := 0
	legendTop    := 0
	if legends {
		opt := DEFAULT_OPTIONS.legend
		[curW, curH] := [width, 0]
		for legend in legends {
			[lw, lh] := canvas.measureText(legend)
			itemWidth := opt.blockWidth + opt.textMargin + lw
			curH = max(curH, lh)
			item := {text: legend, width: itemWidth}
			if newW := curW + itemWidth + opt.itemMargin; newW > width - padding2 {
				legendRows.push({
					height: curH,
					items: [item],
				})
				curW = itemWidth
			} else {
				legendRows[-1].height = curH
				legendRows[-1].items.push(item)
				curW = newW
			}
		}
		for row in legendRows {
			legendHeight += opt.rowMargin + row.height
			row.width = row.items.map('width').reduce()
						+ (len(row.items) - 1) * opt.itemMargin
		}
		legendHeight += (opt.rowMargin - DEFAULT_OPTIONS.padding)
		gBottom -= legendHeight
		gHeight -= legendHeight
		legendTop = gBottom
	}

	if yaxis {
		if isCallable(yaxis) {
			[ys, zero] := yaxis(minValue, maxValue)
			yaxis = ys
			minValue = zero ?? minValue
		}
		maxW := 0
		for item in yaxis {
			if w := canvas.measureText(item.label ?? str(item))[0]; w > maxW {
				maxW = w
			}
			if v := item.value ?? item; v > maxValue {
				maxValue = v
			} else if v < minValue {
				minValue = v
			}
		}
		if yw := options.valueWidth; yw {
			gLeft  += yw + 5
			gWidth -= yw + 5
		} else if maxW > 0 {
			gLeft  += maxW + 5
			gWidth -= maxW + 5
		}
	}
	getY := value => gBottom - gHeight * (value - minValue) / (maxValue - minValue)

	// 绘制标题
	if title {
		canvas.text(title, left + (width - tw) / 2, top + th + 5, '000')
	}
	// 绘制坐标轴
	canvas.line(gLeft, gTop, gLeft, gBottom, '000')
	canvas.line(gLeft, gBottom, gRight, gBottom, '000')
	if yaxis {
		for item in yaxis {
			label := item.label ?? str(item)
			value := item.value ?? item
			[yw, yh] := canvas.measureText(label)
			y := getY(value)
			canvas.text(label, gLeft - 5 - yw, y + yh / 2, '000')
			canvas.line(gLeft + 1, y, gRight, y, 'eee')
		}
	}
	// 绘制names
	if names {
		for i, name in names {
			x := gLeft + (i + 0.5) * gWidth / len(names)
			canvas.line(x, gBottom, x, gBottom + 3, '000')
			canvas.line(x, gTop, x, gBottom, 'eee')
			nw := canvas.measureText(name)[0]
			canvas.text(name, x - nw / 2, gBottom + 5 + nh, '000')
			legendTop = gBottom + 5 + nh
		}
	}

	// 绘制数据
	nDatas := len(datas)
	for j, data in datas {
		color := _colors[j % len(_colors)]
		drawer(
			canvas,
			len(names),
			datas,
			j,
			data,
			color,
			gLeft,
			gBottom,
			gWidth,
			gHeight,
			getY,
		)
	}

	// 绘制legends
	if legendRows {
		opt := DEFAULT_OPTIONS.legend
		y := legendTop + opt.rowMargin
		index := -1
		textOffset := opt.blockWidth + opt.textMargin
		for row in legendRows {
			x := (width - padding2 - row.width) / 2
			for item in row.items {
				index++
				color := _colors[index % len(_colors)]
				canvas.rect(
					x, y,// + (row.height - opt.blockHeight) / 2,
					opt.blockWidth, opt.blockHeight
				).fill(color)
				textH := canvas.measureText(item.text)[1]
				canvas.text(item.text,
					x + textOffset,
					y + opt.blockHeight,
					color,
				)
				x += item.width + opt.itemMargin
			}
			y += row.height + opt.rowMargin
		}
	}

	return canvas
}
